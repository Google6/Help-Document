* 预处理，编译，汇编，连接
    目标                  命令                描述干什么的
1：hello.c  ->  hello.i   -E: 预处理 （展开空，头文件，替换条件编译，注释空白空行）
2：hello.i  ->  hello.s   -S: 编译   （检查语法规范）        （这一步消耗时间和系统资源最大的）
3：hello.s  ->  hello.o   -c: 汇编  （将汇编指令翻译成机器指令）
4：hello.o  ->  a.out   无参数  : 连接 （数据段合并，数据地址回填）
  -o的意思是指定生成目标的名字，不是编译的参数奥


* gcc  编译参数
gcc  main.cpp   -o  hello:
gcc  -I./src   指定包含头文件的路径是当前src下。
-E  ：  只做，预处理 1个步骤
-S  ：  只做，预处理，编译 2个步骤
-c  ：  只做，预处理，编译汇编，3个步骤(得到二进制文件)
-g  ：  加了以后，生成的可执行文件就可以gdb断点调试了
-On  :  0-3  默认是2，越大优化越好，（就是对你写的代码进行优化，比如你写了很多代码可能都执行不到，他就会把他删掉）（很少用到这个命令的）
-Wall ：显示所有的编译过程的警告信息。
-D  ：表示向当前的程序中去定义一个宏，这个宏，程序代码就可以用到它了。 

* 无论在编译静态库还是动态库，如果包含头文件都需要用  -I /yourpath  手动指定路径

* 生成静态库
ar rcs libxx.a   file1.o  file2.o ...
* 使用静态库
g++   main.cpp  libxx.a   -o   main    (就是将静态库和 .a 文件放在一起编译........)

* gcc在编译时候如果遇到一个函数没有显示的定义过，那么编译器就是隐式的声明一个  int xx(xx,xx);返回值为int其他一致的函数 作为默认的函数定义（所以最好先定义在使用）


> 连接的过程，是一个地址回填的过程。根据main函数地址，重新计算库函数的函数地址。
* 生成动态库 
1: g++ -c main.cpp -o main.o  -fPIC 
2: g++ -shared -o  libxx.so   file1.o  file2.o
3: 使用动态库
-l  :用来指定库的名字
-L  :指定库的路径
-I: 头文件路径


ldd   a.out ;   可执行文件 可以帮助查找可执行文件依赖哪些动态库

 




